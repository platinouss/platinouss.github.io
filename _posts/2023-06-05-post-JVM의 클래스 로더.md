---
title:  "[JVM] JVM의 클래스로더(ClassLoader)"
excerpt: "JVM에서의 클래스 로딩 기법에 대해 알아보자"

categories:
  - jvm
tags:
  - ClassLoader

toc: true

date: 2023-06-15
last_modified_at: 2023-06-15
---

## 개요
JVM 관점에서 클래스(Class)는 JVM 프로세스를 개별적으로 로드하고 실행할 수 있는 컴파일 단위이다.  
이번 포스팅에서는 JVM에서 클래스들을 어떻게 탐색하고 로드하는지 알아보자.

<center>
    <img src="/assets/images/JVM/ClassLoader/1.png" title="JVM Architecture - ClassLoader"/> 
</center>

## JVM의 클래스 로딩 과정
다음과 같은 코드가 있다고 가정하자.

```java
public class A { 
   public static void main(String[] args) {
      B b = new B();
      int i = b.inc(0); 
      System.out.println(i); 
   } 
}
```
위의 코드가 컴파일되어 실행되면, 클래스 A의 main() 메서드가 실행될 것이다.

위 main()메서드가 정상적으로 실행되기 위해서는 클래스 B와 같은 다양한 클래스가 로드되어야 할텐데, 일반적으로 JVM은 **new B()에 해당하는 바이트 코드를 마주쳤을 때**, 그때 클래스 B를 찾고 로드하게 된다.

<center>
    <img src="/assets/images/JVM/ClassLoader/2.png" title="Java Reference - ClassLoader"/> 
</center>

<br>

JVM은 클래스를 로드하기 위해 ClassLoader 객체를 사용한다. 이미 로드된 클래스들은 자신의 클래스로더를 가지고 있으며, 이 클래스로더는 해당 클래스에서 사용되는 모든 클래스를 로드하는데 사용된다. 가령 위의 예시에서 로딩 클래스인 B는 A.class.getClassLoader().loadClass("B")로 변환될 수 있다.

그럼 JDK 내부에 있는 모든 클래스들(ex. java.lang.Object, java.lang.ClassLoader 등)을 로드하는 첫 클래스로더는 무엇이며 어떻게 생성될까? 다음 `클래스로더의 계층 구조` 파트에서 살펴보자. 

## 클래스로더의 계층 구조
<center>
    <img src="/assets/images/JVM/ClassLoader/3.png" width="90%" height="90%" title="ClassLoader Hierarchy"/> 
</center>

JVM의 클래스로더는 부모를 가지고 있는 트리 계층으로 구성된다. 일반적으로 클래스로더의 책임을 분리하고, 클래스로더가 특정한 위치에서만 클래스를 로드하도록 한다.

JDK11 기준 JVM은 크게 3가지 역할을 가진 ClassLoader가 존재한다. (명칭은 다를 수 있으나 역할은 동일하다.)

### Bootstrap ClassLoader (BootClassLoader)
- 최상위 클래스로더로, 다른 클래스로더가 나머지 시스템에 필요한 클래스를 로드할 수 있도록 최소한의 필수 클래스(ex. java.lang 패키지의 클래스, Java primitives 클래스 등)를 로드한다.
- 플랫폼에 의존하는 네이티브 코드로 구현되어있다.

### Extensions ClassLoade (PlatformClassLoder)
- 확장 디렉토리에서 클래스를 로드하는 클래스로더이다.
- 로드 되는 클래스는 locales, security provider 등과 같이 시스템별 configuration을 지정하는데 사용된다.

### System ClassLoader (AppClassLoader)
- 지정된 클래스 경로에 위치한 유저 클래스를 로드하는 클래스로더이다.
- `Extensions ClassLoader`와 `System ClassLoader`는 모두 URLClassLoader를 상속받아 만들어진 클래스로더이다.

## 클래스로더의 3가지 원칙
위에서 소개한 3가지의 클래스로더는 3가지 원칙에 의해 작동된다.

### Dlegation Principle (위임 원칙)
- 자식 클래스로더가 클래스 로드 요청을 부모 클래스로더로 전달하고, 부모 클래스로더가 해당 클래스를 로드할 수 없는 경우에만 클래스를 로드한다.
- 만약 최하위 클래스로더도 해당 클래스를 로드하지 못하면, ClassNotFoundException 또는 NoClassDeffFoudError를 던진다.

### Visibility Principle (가시성 원칙)
- 자식 클래스로더가 부모 클래스로더에 의해 로드된 클래스를 확인할 수 있다. 
- 반면에 부모 클래스로더는 자식 클래스가 로드한 클래스를 확인할 수 없다.
- ex) System ClassLoader는 Extensions 및 Bootstrap ClassLoader에 의해 로드된 클래스를 확인할 수 있다.

### Uniqueness Principle (유일성 원칙)
- 부모 클래스로더에 의해 이미 로드된 클래스는, 자식 클래스로더에 의해 다시 로드되지 않는다.

## 클래스로더의 동작 방식
(작성 중)

## 결론
자바는 클래스를 로드할 때, 런타임 환경에서 해당 클래스를 나타내는 Class 객체를 만든다. 한 시스템에서 클래스는 `패키지명을 포함한 클래스 명`과 `자신을 로드한 클래스로더` 두 가지 정보로 식별된다. 

## 참고
- [**blogs.oracle.com - How the JVM Locates, Loads, and Runs Libraries**](https://blogs.oracle.com/javamagazine/post/how-the-jvm-locates-loads-and-runs-libraries)
- [**The JVM Architecture Explained**](https://dzone.com/articles/jvm-architecture-explained)
- [**Benjamin J. Evans, 『Optimizing Java』 (Oreilly & Associates Inc, 2018)**](https://product.kyobobook.co.kr/detail/S000001810148)